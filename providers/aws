#!/usr/bin/env bash
# AWS Route53 DNS Provider for dokku-dns

dns_provider_aws_validate_credentials() {
  # Check if aws-cli is available
  if ! command -v aws >/dev/null 2>&1; then
    dokku_log_fail "AWS CLI is not installed. Please install aws-cli to use AWS Route53 provider.
    
Run: dokku $PLUGIN_COMMAND_PREFIX:verify"
  fi

  # Check if AWS CLI is configured and working
  if ! aws sts get-caller-identity >/dev/null 2>&1; then
    dokku_log_fail "AWS CLI is not configured or credentials are invalid.
    
Run: dokku $PLUGIN_COMMAND_PREFIX:verify"
  fi

  return 0
}

dns_provider_aws_setup_env() {
  # Rely entirely on existing AWS CLI configuration
  # AWS CLI will use its default configuration from:
  # - ~/.aws/credentials and ~/.aws/config files
  # - Environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_DEFAULT_REGION)
  # - IAM roles (if running on EC2)
  # - AWS SSO
  true  # No-op function, kept for compatibility
}

dns_provider_aws_get_hosted_zone_id() {
  local DOMAIN="$1"
  
  # Quick check for obviously problematic domains
  if [[ "$DOMAIN" == *"example.com"* ]]; then
    # Skip example.com domains entirely - they won't have real hosted zones
    return 1
  fi
  
  # First try exact match for the domain
  local HOSTED_ZONE_ID
  HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='${DOMAIN}.'].Id" --output text 2>/dev/null | sed 's|/hostedzone/||')
  
  if [[ -n "$HOSTED_ZONE_ID" ]] && [[ "$HOSTED_ZONE_ID" != "None" ]]; then
    echo "$HOSTED_ZONE_ID"
    return 0
  fi
  
  # For non-example domains, try simple parent domain logic
  # Only check one level up for now to avoid complexity
  if [[ "$DOMAIN" == *.*.* ]]; then
    # Remove first subdomain: subdomain.domain.com -> domain.com
    local PARENT_DOMAIN="${DOMAIN#*.}"
    
    HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='${PARENT_DOMAIN}.'].Id" --output text 2>/dev/null | sed 's|/hostedzone/||')
    
    if [[ -n "$HOSTED_ZONE_ID" ]] && [[ "$HOSTED_ZONE_ID" != "None" ]]; then
      echo "$HOSTED_ZONE_ID"
      return 0
    fi
  fi
  
  # No hosted zone found
  return 1
}

dns_provider_aws_create_record() {
  local DOMAIN="$1"
  local RECORD_TYPE="$2"
  local RECORD_VALUE="$3"
  local TTL="${4:-300}"
  
  local HOSTED_ZONE_ID
  HOSTED_ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN")
  
  if [[ -z "$HOSTED_ZONE_ID" ]]; then
    dokku_log_fail "No hosted zone found for domain: $DOMAIN. Ensure the domain or its parent domain has a hosted zone in Route53."
  fi
  
  # Create change batch JSON
  local CHANGE_BATCH
  CHANGE_BATCH=$(cat <<EOF
{
  "Changes": [
    {
      "Action": "UPSERT",
      "ResourceRecordSet": {
        "Name": "$DOMAIN",
        "Type": "$RECORD_TYPE",
        "TTL": $TTL,
        "ResourceRecords": [
          {
            "Value": "$RECORD_VALUE"
          }
        ]
      }
    }
  ]
}
EOF
)
  
  # Submit the change
  local CHANGE_ID
  CHANGE_ID=$(aws route53 change-resource-record-sets \
    --hosted-zone-id "$HOSTED_ZONE_ID" \
    --change-batch "$CHANGE_BATCH" \
    --query 'ChangeInfo.Id' \
    --output text 2>/dev/null)
    
  if [[ -n "$CHANGE_ID" ]]; then
    dokku_log_info1 "DNS record created/updated: $DOMAIN -> $RECORD_VALUE"
    dokku_log_verbose "Change ID: $CHANGE_ID"
    return 0
  else
    dokku_log_fail "Failed to create/update DNS record for $DOMAIN"
  fi
}

dns_provider_aws_delete_record() {
  local DOMAIN="$1"
  local RECORD_TYPE="$2"
  local RECORD_VALUE="$3"
  
  local HOSTED_ZONE_ID
  HOSTED_ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN")
  
  if [[ -z "$HOSTED_ZONE_ID" ]]; then
    dokku_log_warn "No hosted zone found for domain: $DOMAIN"
    return 0
  fi
  
  # Create change batch JSON for deletion
  local CHANGE_BATCH
  CHANGE_BATCH=$(cat <<EOF
{
  "Changes": [
    {
      "Action": "DELETE",
      "ResourceRecordSet": {
        "Name": "$DOMAIN",
        "Type": "$RECORD_TYPE",
        "ResourceRecords": [
          {
            "Value": "$RECORD_VALUE"
          }
        ]
      }
    }
  ]
}
EOF
)
  
  # Submit the change
  local CHANGE_ID
  CHANGE_ID=$(aws route53 change-resource-record-sets \
    --hosted-zone-id "$HOSTED_ZONE_ID" \
    --change-batch "$CHANGE_BATCH" \
    --query 'ChangeInfo.Id' \
    --output text 2>/dev/null)
    
  if [[ -n "$CHANGE_ID" ]]; then
    dokku_log_info1 "DNS record deleted: $DOMAIN"
    return 0
  else
    dokku_log_warn "Failed to delete DNS record for $DOMAIN (may not exist)"
  fi
}

dns_provider_aws_list_records() {
  local DOMAIN="$1"
  
  local HOSTED_ZONE_ID
  HOSTED_ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN")
  
  if [[ -z "$HOSTED_ZONE_ID" ]]; then
    dokku_log_warn "No hosted zone found for domain: $DOMAIN"
    return 0
  fi
  
  aws route53 list-resource-record-sets \
    --hosted-zone-id "$HOSTED_ZONE_ID" \
    --query "ResourceRecordSets[?Name=='${DOMAIN}.']" \
    --output table 2>/dev/null
}

dns_provider_aws_discover_existing_domains() {
  # Discover existing A records for domains that are registered with Dokku apps
  
  local HOSTED_ZONES
  HOSTED_ZONES=$(aws route53 list-hosted-zones --query 'HostedZones[].Id' --output text 2>/dev/null | sed 's|/hostedzone/||g')
  
  if [[ -z "$HOSTED_ZONES" ]]; then
    dokku_log_info1 "No hosted zones found in Route53"
    return 0
  fi
  
  # Get all domains from all Dokku apps
  local ALL_DOKKU_DOMAINS=""
  local APPS_LIST
  APPS_LIST=$(dokku apps:list 2>/dev/null | grep -v "====>" || echo "")
  
  if [[ -z "$APPS_LIST" ]]; then
    dokku_log_info1 "No Dokku apps found - cannot filter DNS records"
    return 0
  fi
  
  # Collect all domains from all apps
  while IFS= read -r APP; do
    [[ -z "$APP" ]] && continue
    local APP_DOMAINS
    APP_DOMAINS=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")
    if [[ -n "$APP_DOMAINS" ]]; then
      # Convert space-separated domains to newline-separated
      for DOMAIN in $APP_DOMAINS; do
        ALL_DOKKU_DOMAINS="$ALL_DOKKU_DOMAINS
$DOMAIN"
      done
    fi
  done <<< "$APPS_LIST"
  
  # Also include global domains
  local GLOBAL_DOMAINS
  GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null || echo "")
  if [[ -n "$GLOBAL_DOMAINS" ]]; then
    # Convert space-separated global domains to newline-separated
    for DOMAIN in $GLOBAL_DOMAINS; do
      ALL_DOKKU_DOMAINS="$ALL_DOKKU_DOMAINS
$DOMAIN"
    done
  fi
  
  # Remove empty lines and duplicates
  ALL_DOKKU_DOMAINS=$(echo "$ALL_DOKKU_DOMAINS" | grep -v "^$" | sort -u)
  
  if [[ -z "$ALL_DOKKU_DOMAINS" ]]; then
    dokku_log_info1 "No domains configured in any Dokku apps"
    return 0
  fi
  
  dokku_log_info2 "Discovering DNS records for Dokku-registered domains..."
  
  local ZONE_COUNT=0
  local RECORD_COUNT=0
  local MATCHED_COUNT=0
  
  for ZONE_ID in $HOSTED_ZONES; do
    ((ZONE_COUNT++))
    
    # Get zone name for display
    local ZONE_NAME
    ZONE_NAME=$(aws route53 get-hosted-zone --id "$ZONE_ID" --query 'HostedZone.Name' --output text 2>/dev/null | sed 's/\.$//')
    
    # List all A records in this zone (excluding NS, SOA, etc.)
    local A_RECORDS
    A_RECORDS=$(aws route53 list-resource-record-sets \
      --hosted-zone-id "$ZONE_ID" \
      --query "ResourceRecordSets[?Type==\`A\`].{Name:Name,Value:ResourceRecords[0].Value}" \
      --output text 2>/dev/null)
    
    local ZONE_MATCHED=false
    
    if [[ -n "$A_RECORDS" ]]; then
      while IFS=$'\t' read -r DOMAIN IP; do
        # Remove trailing dot from domain name
        DOMAIN="${DOMAIN%.}"
        if [[ -n "$DOMAIN" ]] && [[ -n "$IP" ]]; then
          ((RECORD_COUNT++))
          
          # Check if this domain is registered with Dokku
          if echo "$ALL_DOKKU_DOMAINS" | grep -q "^${DOMAIN}$"; then
            if [[ "$ZONE_MATCHED" == false ]]; then
              dokku_log_info1 "Zone: $ZONE_NAME ($ZONE_ID)"
              ZONE_MATCHED=true
            fi
            echo "  ✓ $DOMAIN → $IP"
            ((MATCHED_COUNT++))
          fi
        fi
      done <<< "$A_RECORDS"
    fi
    
    if [[ "$ZONE_MATCHED" == true ]]; then
      echo
    fi
  done
  
  if [[ "$MATCHED_COUNT" -eq 0 ]]; then
    dokku_log_info1 "No DNS records found for Dokku-registered domains"
    dokku_log_info1 "Dokku domains that could be synced:"
    echo "$ALL_DOKKU_DOMAINS" | while IFS= read -r DOMAIN; do
      echo "  • $DOMAIN"
    done
  else
    dokku_log_info2 "Discovery complete: Found $MATCHED_COUNT Dokku-registered domains out of $RECORD_COUNT total A records across $ZONE_COUNT hosted zones"
  fi
}

dns_provider_aws_sync_app() {
  local SERVICE="$1"  # Not used in global mode, kept for compatibility
  local APP="$2"
  
  # Handle both service-based (legacy) and global mode calls
  if [[ -z "$APP" ]]; then
    # If only one parameter, it's the app name (global mode)
    APP="$SERVICE"
  fi
  
  dns_provider_aws_validate_credentials
  dns_provider_aws_setup_env
  
  # Get all domains for the app from Dokku
  local APP_DOMAINS
  APP_DOMAINS=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null)
  
  if [[ -z "$APP_DOMAINS" ]]; then
    dokku_log_warn "No domains configured for app: $APP"
    return 0
  fi
  
  # Get the server's IP (where this Dokku instance is running)
  # We'll use the global domains to determine the server IP
  local SERVER_IP
  local GLOBAL_DOMAINS
  GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null)
  
  if [[ -n "$GLOBAL_DOMAINS" ]]; then
    # Use the first global domain to resolve server IP
    local FIRST_GLOBAL_DOMAIN
    FIRST_GLOBAL_DOMAIN=$(echo "$GLOBAL_DOMAINS" | head -n1)
    SERVER_IP=$(dig +short "$FIRST_GLOBAL_DOMAIN" | tail -n1)
  fi
  
  # If no global domains or couldn't resolve, try to get server IP another way
  if [[ -z "$SERVER_IP" ]]; then
    # Try to get the server's public IP
    SERVER_IP=$(curl -s ifconfig.me 2>/dev/null || curl -s ipecho.net/plain 2>/dev/null || curl -s icanhazip.com 2>/dev/null)
  fi
  
  if [[ -z "$SERVER_IP" ]]; then
    dokku_log_fail "Could not determine server IP. Please ensure your server has internet access or configure global domains."
  fi
  
  dokku_log_info2 "Syncing domains for app '$APP' to server IP: $SERVER_IP"
  
  # Sync each domain
  for DOMAIN in $APP_DOMAINS; do
    [[ -z "$DOMAIN" ]] && continue
    dokku_log_info1 "Syncing domain: $DOMAIN"
    dns_provider_aws_create_record "$DOMAIN" "A" "$SERVER_IP"
  done
}